[{"content":"zyt大佬捏：horostal.github.io\nVirgenene(维吉尼亚) 取一个长度为$x$的$key$，则在每一个长度为$x$的明文区间内，每一个字母本身都在进行凯撒式移位加密。例如选取$key$为vector，则对应数字为(21, 4, 2, 19, 14, 17)，之后对明文进行加密：\n1 2 3 (明文) h e r e i s h o w i t w o r k s (密钥) 21 4 2 19 14 17 21 4 2 19 14 17 21 4 2 19 (密文) c i t x w j c s y b h n j v m l 那如果有密文，可以通过猜测明文前几位算出$key$，找到循环点并截取出正确的$key$，在进行解密即可。推荐一个爆破维吉尼亚的网站：https://www.guballa.de/vigenere-solver，下面是自己手撸的加解密和猜测密钥。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 def encode(plaintext, key): li = [] j = 0 for i in range(len(plaintext)): if \u0026#39;a\u0026#39; \u0026lt;= plaintext[i] \u0026lt;= \u0026#39;z\u0026#39;: li.append(chr((ord(plaintext[i]) - ord(\u0026#39;a\u0026#39;) + ord(key[j].lower()) - ord(\u0026#39;a\u0026#39;)) % 26 + ord(\u0026#39;a\u0026#39;))) j = (j + 1) % len(key) elif \u0026#39;A\u0026#39; \u0026lt;= plaintext[i] \u0026lt;= \u0026#39;Z\u0026#39;: li.append(chr((ord(plaintext[i]) - ord(\u0026#39;A\u0026#39;) + ord(key[j].upper()) - ord(\u0026#39;A\u0026#39;)) % 26 + ord(\u0026#39;A\u0026#39;))) j = (j + 1) % len(key) else: li.append(plaintext[i]) print(\u0026#39;\u0026#39;.join(li)) # print(\u0026#39;\u0026#39;.join([chr((ord(st[i]) - ord(\u0026#39;a\u0026#39;) + ord(s[i % len(s)]) - ord(\u0026#39;a\u0026#39;)) % 26 + ord(\u0026#39;a\u0026#39;)) for i in range(len(st))])) def decode(ciphertext, key): li = [] j = 0 for i in range(len(ciphertext)): if \u0026#39;a\u0026#39; \u0026lt;= ciphertext[i] \u0026lt;= \u0026#39;z\u0026#39;: li.append(chr((ord(ciphertext[i]) - ord(key[j].lower())) % 26 + ord(\u0026#39;a\u0026#39;))) j = (j + 1) % len(key) elif \u0026#39;A\u0026#39; \u0026lt;= ciphertext[i] \u0026lt;= \u0026#39;Z\u0026#39;: li.append(chr((ord(ciphertext[i]) - ord(key[j].upper())) % 26 + ord(\u0026#39;A\u0026#39;))) j = (j + 1) % len(key) else: li.append(ciphertext[i]) print(\u0026#39;\u0026#39;.join(li)) # print(\u0026#39;\u0026#39;.join([chr((ord(t[i]) - ord(\u0026#39;a\u0026#39;) - ord(s[i % len(s)]) + ord(\u0026#39;a\u0026#39;)) % 26 + ord(\u0026#39;a\u0026#39;)) for i in range(len(t))])) def check(plaintext, ciphertext): t = min(len(plaintext), len(ciphertext)) li = [] for i in range(t): if \u0026#39;a\u0026#39; \u0026lt;= ciphertext[i] \u0026lt;= \u0026#39;z\u0026#39;: li.append(chr((ord(ciphertext[i]) - ord(plaintext[i].lower())) % 26 + ord(\u0026#39;a\u0026#39;))) elif \u0026#39;A\u0026#39; \u0026lt;= ciphertext[i] \u0026lt;= \u0026#39;Z\u0026#39;: li.append(chr((ord(ciphertext[i]) - ord(plaintext[i].upper())) % 26 + ord(\u0026#39;A\u0026#39;))) else: continue return \u0026#39;\u0026#39;.join(li) # \u0026#39;\u0026#39;.join([chr((ord(ciphertext[i]) - ord(plaintext[i])) % 26 + ord(\u0026#39;a\u0026#39;)) for i in range(t)]) ","date":"2025-03-13T18:00:00+08:00","image":"https://skyhaibara.github.io/Zs.png","permalink":"https://skyhaibara.github.io/p/ctf-crypto/","title":"CTF Crypto"},{"content":"Misc Kali（Linux系统） extundelete 1 2 3 4 5 6 7 8 9 10 # 在linux上挂载光盘的命令 mkdir /mnt/disk mount attachment.img /mnt/disk/ cd /mnt/disk #可以使用 eog 图片名 命令来查看图片 #使用结束后用 umount: /mnt/disk #命令取消挂载 extundelete --restore-all attachment.img # 数据恢复成功后会生成一个 RECOVERED_FILES 文件 压缩包套娃 1 2 while [ \u0026#34;find . -type f -name \u0026#39;*.tar.xz\u0026#39; | wc -l\u0026#34; -gt 0 ]; do find -type f -name \u0026#34;*.tar.xz\u0026#34; -exec tar xf \u0026#39;{}\u0026#39; \\; -exec rm -- \u0026#39;{}\u0026#39; \\;; done; strings flag 查找flag字符 LSB（老色比） 1 2 3 4 5 zsteg -e \u0026#34;b8,rgb,lsb,xy\u0026#34; 1.png \u0026gt; diskimage.dat testdisk : testdisk diskimage.dat C to copy the selected files, c to copy the current file Traffic（流量） SMTP TLS 1 2 3 4 5 -----BEGIN RSA PRIVATE KEY----- XXXXXXX -----END RSA PRIVATE KEY----- wireshark 编辑即可 SMB+hascat 省赛的题目复现，讲一下自己的理解 Code（编码） 猪圈密码： 多类变种 圣堂武士密码（猪圈密码的变种）： 小猫密码： 五笔密码： 提瓦特大陆： 古埃及象形文字： 外星人密码： 克林贡语密码《星际迷航》： 元素周期表： 狄德拉字符(暗精灵活神)： 银河字母(游戏《指挥官基恩》)： 跳舞的小人： 旗语密码： 国际船用信号旗： 夏多密码（又称曲折密码）: 在以上所示的字母表密钥的底部，列有四个附加符号1，2，3，4.他们可以放在密文中的任何地方。每个附加符号指示，如何转动写有密文的纸张，再进行后续的加密或解密操作，直到出现另一个附加符号。 可以把每个附加符号中的那根线看作是指示针，它指示了纸张的上端朝上，朝下，朝左，朝右。比如说： 如果出现符号3，那么纸张就应该转动180度，使其上端朝下； 符号2表示纸张上端朝右； 符号4表示纸张上端朝左； 符号1表示纸张上端朝上\n多斯拉克语字母表： 海利亚文字： Covenant字体： top cipher: exp:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 cipherList = {\u0026#39;M\u0026#39;:\u0026#39;ACEG\u0026#39;,\u0026#39;R\u0026#39;:\u0026#39;ADEG\u0026#39;,\u0026#39;K\u0026#39;:\u0026#39;BCEG\u0026#39;,\u0026#39;S\u0026#39;:\u0026#39;BDEG\u0026#39;,\u0026#39;A\u0026#39;:\u0026#39;ACEH\u0026#39;,\u0026#39;B\u0026#39;:\u0026#39;ADEH\u0026#39;,\u0026#39;L\u0026#39;:\u0026#39;BCEH\u0026#39;,\u0026#39;U\u0026#39;:\u0026#39;BDEH\u0026#39;,\u0026#39;D\u0026#39;:\u0026#39;ACEI\u0026#39;,\u0026#39;C\u0026#39;:\u0026#39;ADEI\u0026#39;,\u0026#39;N\u0026#39;:\u0026#39;BCEI\u0026#39;,\u0026#39;V\u0026#39;:\u0026#39;BDEI\u0026#39;,\u0026#39;H\u0026#39;:\u0026#39;ACFG\u0026#39;,\u0026#39;F\u0026#39;:\u0026#39;ADFG\u0026#39;,\u0026#39;O\u0026#39;:\u0026#39;BCFG\u0026#39;,\u0026#39;W\u0026#39;:\u0026#39;BDFG\u0026#39;,\u0026#39;T\u0026#39;:\u0026#39;ACFH\u0026#39;,\u0026#39;G\u0026#39;:\u0026#39;ADFH\u0026#39;,\u0026#39;P\u0026#39;:\u0026#39;BCFH\u0026#39;,\u0026#39;X\u0026#39;:\u0026#39;BDFH\u0026#39;,\u0026#39;E\u0026#39;:\u0026#39;ACFI\u0026#39;,\u0026#39;I\u0026#39;:\u0026#39;ADFI\u0026#39;,\u0026#39;Q\u0026#39;:\u0026#39;BCFI\u0026#39;,\u0026#39;Y\u0026#39;:\u0026#39;BDFI\u0026#39;} flag1 = \u0026#34;\u0026#34; # s = \u0026#39;BCEHACEIBDEIBDEHBDEHADEIACEGACFIBDFHACEGBCEHBCFIBDEGBDEGADFGBDEHBDEGBDFHBCEGACFIBCFGADEIADEIADFH\u0026#39; # for i in range(0,len(s),4): # block = s[i:i+4] # for j in cipherList: # if block==cipherList[j]: # flag1 += j # print(flag1) s2 = \u0026#34;LDVUUCMEXMLQSSFUSXKEOCCG\u0026#34; cipherList2 = [\u0026#39;M\u0026#39;, \u0026#39;R\u0026#39;, \u0026#39;K\u0026#39;, \u0026#39;S\u0026#39;, \u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;, \u0026#39;L\u0026#39;, \u0026#39;U\u0026#39;, \u0026#39;D\u0026#39;, \u0026#39;C\u0026#39;, \u0026#39;N\u0026#39;, \u0026#39;V\u0026#39;, \u0026#39;H\u0026#39;, \u0026#39;F\u0026#39;, \u0026#39;O\u0026#39;, \u0026#39;W\u0026#39;, \u0026#39;T\u0026#39;, \u0026#39;G\u0026#39;, \u0026#39;P\u0026#39;, \u0026#39;X\u0026#39;, \u0026#39;E\u0026#39;, \u0026#39;I\u0026#39;, \u0026#39;Q\u0026#39;, \u0026#39;Y\u0026#39;] # cipherList2.reverse() cipherList3 = [\u0026#39;Y\u0026#39;, \u0026#39;Q\u0026#39;, \u0026#39;I\u0026#39;, \u0026#39;E\u0026#39;, \u0026#39;X\u0026#39;, \u0026#39;P\u0026#39;, \u0026#39;G\u0026#39;, \u0026#39;T\u0026#39;, \u0026#39;W\u0026#39;, \u0026#39;O\u0026#39;, \u0026#39;F\u0026#39;, \u0026#39;H\u0026#39;, \u0026#39;V\u0026#39;, \u0026#39;N\u0026#39;, \u0026#39;C\u0026#39;, \u0026#39;D\u0026#39;, \u0026#39;U\u0026#39;, \u0026#39;L\u0026#39;, \u0026#39;B\u0026#39;, \u0026#39;A\u0026#39;, \u0026#39;S\u0026#39;, \u0026#39;K\u0026#39;, \u0026#39;R\u0026#39;, \u0026#39;M\u0026#39;] flag2 = \u0026#39;\u0026#39; for i in s2: for j in cipherList2: if i==j: rank = cipherList2.index(j) flag2 += cipherList3[rank] print(flag2) Matlab -\u0026gt; Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 fid=fopen(\u0026#39;33.wav\u0026#39;,\u0026#39;rb\u0026#39;); a=fread(fid,inf,\u0026#39;uchar\u0026#39;);\tn=length(a)-44; fclose(fid); io=imread(\u0026#39;kkk.bmp\u0026#39;);\t[row col]=size(io);\t# 返回图像尺寸 wi=io(:);\t# 二维转一维 if row*col\u0026gt;n error(\u0026#39;文件太小\u0026#39;);\t# 要隐写的目的文件要够大 end watermarkedaudio=a; watermarklength=row*col; for k=1:row*col\t# 从1到row*col watermarkedaudio(44+k)=bitset(watermarkedaudio(44+k),1,wi(k)); end figure; subplot(2,1,1);plot(a); subplot(2,1,2);plot(watermarkedaudio); fid = fopen(\u0026#39;2.wav\u0026#39;, \u0026#39;wb\u0026#39;); fwrite(fid,watermarkedaudio,\u0026#39;uchar\u0026#39;); fclose(fid); fread : 从二进制文件读取数据 inf : 读出fid指向的打开的文件的全部数据 imread : 读取图像 bitset(A,pos,V) ：将A以二进制来表示，并将第pos个位置（从右数）， 设置为 V 的值，在将所得到的值转换成10进制数并返回。 figure ：使用默认属性值创建一个新的图窗窗口 subplot ：将当前图窗划分为 m×n 网格，并在 p 指定的位置创建坐标区 plot ( Y ) 绘制 Y 对一组隐式 x 坐标的图。 如果 Y 是向量，则 x 坐标范围从 1 到 length( Y )。 如果 Y 是矩阵，则对于 Y 中的每个列，图中包含一个对应的行。x 坐标的范围是从 1 到 Y 的行数。 1 2 3 4 5 6 7 8 9 10 11 12 13 import numpy as np from PIL import Image wav = open(\u0026#39;aaa.wav\u0026#39;,\u0026#39;rb\u0026#39;) content = wav.read() wav.close() bins = [] for i in range(45,45+388*100): bins.append(255 if int(bin(content[i])[-1:]) else 0) flag = np.array(bins,np.uint8).reshape(388,100) imgg = Image.fromarray(flag).save(\u0026#39;res.bmp\u0026#39;) Excel 将表格全选，选择菜单栏中的， 表单格式 =\u0026gt; 突出显示单元格规则 =\u0026gt; 文本包含 ##pwntools\n1 2 3 4 5 6 7 8 9 send(data): 发送数据 sendline(data) : 发送一行数据，相当于在末尾加\u0026#39;\\n\u0026#39; recv(numb=4096, timeout=default) : 给出接收字节数,timeout指定超时 recvuntil(delims, drop=False) : 接收到delims的pattern （以下可以看作until的特例） recvline(keepends=True) : 接收到\u0026#34;\\n，keepends指定保留\\n\u0026#34; recvall() : 接收到EOF recvrepeat(timeout=default) : 接收到EOF或timeout interactive() : 与shell交互 相关工具使用 basecrack4.0v 1 basecrack.py -m 自动化处理 Mimikatz \u0026ndash;dmp文件 1 2 sekurlsa::minidump lsass.dmp --加载 sekurlsa::logonpasswords full --导出密码散列值 ","date":"2025-03-06T18:00:00+08:00","image":"https://skyhaibara.github.io/Mc.png","permalink":"https://skyhaibara.github.io/p/ctf-misc/","title":"CTF Misc"}]